package decorator_pattern;

/*
 *Created by zx on 19-2-2
 *
 * 装饰者模式
 * 名称解释：动态地给 对象添加一些额外的职责，就功能来说装饰者模式相比生成子类更为灵活
 * 以上解释是引自GOF所著的《Design Pattern》对建造者模式的高度概括。
 * 通俗的理解就是，装饰者模式是动态地拓展一个对象的功能，而不需要改变原始类代码的一种成熟模式。
 *
 * 其结构包含四个角色
 * 1.抽象组件(Component):抽象组件是一个抽象类，其定义了“被装饰者”需要进行“装饰”的方法
 * 2.具体组件(ConcreteComponent):具体组件是抽象组件的一个子类，具体组件的实例称为“被装饰者”
 * 3.装饰(Decorator):装饰也是抽象组件的子类，但装饰还包含一个抽象组件声明的变量以保存“被装饰者”的引用，该类可以是抽象的也可以是非抽象的。
 * 4.具体装饰(ConcreteDecotatoro):具体装饰是装饰的一个非抽象子类，具体装饰的实例称为“装饰者”
 *
 * 以我个人的理解来说，以上四个角色可以分位二类，抽象组件和具体组件一类，装饰和具体装饰一类
 * 抽象组件是要装饰对象的一般抽象描述，其具体实现是具体组件，装饰可以理解位抽象装饰者，是从外部来拓展抽象组件的类，它持有对抽象组件的引用，好调用其实现类的方法
 * 而具体装饰是装饰的实现类
 *
 * 模式分析：
 * 优点：被装饰者和装饰者是松耦合关系，通过组合方式来拓展一个类的功能，在选择不同的装饰者的前提下可以实现不同的行为。有效的避免了通过继承
 *      方式来实现拓展功能，满足开闭原则。也可以使用多个具体组件装饰来装饰具体组件的实例。
 * 使用场景：希望通过动态的增强类的某个对象的功能，而不影响到该类的其他对象，当不采用继承方式来增强对象功能时，不利于你系统的维护和拓展。
 *
 *
 * 以下通过来拓展汽车某项功能的例子来说明装饰者模式
 *
 */
public class DecoratorPattern {

    public DecoratorPattern() {
        SuvCar suvCar=new SuvCar();
        ConcreteDecoratorCar concreteDecoratorCar=new ConcreteDecoratorCar(suvCar);
        concreteDecoratorCar.drive();
    }
}
